{"ast":null,"code":"/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n  constructor(callback, type, updateInterval) {\n    this._callback = callback;\n    this._type = type;\n    this._updateInterval = updateInterval;\n    // create the clock source for the first time\n    this._createClock();\n  }\n  /**\n   * Generate a web worker\n   */\n  _createWorker() {\n    const blob = new Blob([/* javascript */`\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`], {\n      type: \"text/javascript\"\n    });\n    const blobUrl = URL.createObjectURL(blob);\n    const worker = new Worker(blobUrl);\n    worker.onmessage = this._callback.bind(this);\n    this._worker = worker;\n  }\n  /**\n   * Create a timeout loop\n   */\n  _createTimeout() {\n    this._timeout = setTimeout(() => {\n      this._createTimeout();\n      this._callback();\n    }, this._updateInterval * 1000);\n  }\n  /**\n   * Create the clock source.\n   */\n  _createClock() {\n    if (this._type === \"worker\") {\n      try {\n        this._createWorker();\n      } catch (e) {\n        // workers not supported, fallback to timeout\n        this._type = \"timeout\";\n        this._createClock();\n      }\n    } else if (this._type === \"timeout\") {\n      this._createTimeout();\n    }\n  }\n  /**\n   * Clean up the current clock source\n   */\n  _disposeClock() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = 0;\n    }\n    if (this._worker) {\n      this._worker.terminate();\n      this._worker.onmessage = null;\n    }\n  }\n  /**\n   * The rate in seconds the ticker will update\n   */\n  get updateInterval() {\n    return this._updateInterval;\n  }\n  set updateInterval(interval) {\n    this._updateInterval = Math.max(interval, 128 / 44100);\n    if (this._type === \"worker\") {\n      this._worker.postMessage(Math.max(interval * 1000, 1));\n    }\n  }\n  /**\n   * The type of the ticker, either a worker or a timeout\n   */\n  get type() {\n    return this._type;\n  }\n  set type(type) {\n    this._disposeClock();\n    this._type = type;\n    this._createClock();\n  }\n  /**\n   * Clean up\n   */\n  dispose() {\n    this._disposeClock();\n  }\n}","map":null,"metadata":{},"sourceType":"module"}