{"ast":null,"code":"import { StereoEffect } from \"./StereoEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Phaser is a phaser effect. Phasers work by changing the phase\n * of different frequency components of an incoming signal. Read more on\n * [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)).\n * Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).\n * @example\n * const phaser = new Tone.Phaser({\n * \tfrequency: 15,\n * \toctaves: 5,\n * \tbaseFrequency: 1000\n * }).toDestination();\n * const synth = new Tone.FMSynth().connect(phaser);\n * synth.triggerAttackRelease(\"E3\", \"2n\");\n * @category Effect\n */\nexport class Phaser extends StereoEffect {\n  constructor() {\n    super(optionsFromArguments(Phaser.getDefaults(), arguments, [\"frequency\", \"octaves\", \"baseFrequency\"]));\n    this.name = \"Phaser\";\n    const options = optionsFromArguments(Phaser.getDefaults(), arguments, [\"frequency\", \"octaves\", \"baseFrequency\"]);\n    this._lfoL = new LFO({\n      context: this.context,\n      frequency: options.frequency,\n      min: 0,\n      max: 1\n    });\n    this._lfoR = new LFO({\n      context: this.context,\n      frequency: options.frequency,\n      min: 0,\n      max: 1,\n      phase: 180\n    });\n    this._baseFrequency = this.toFrequency(options.baseFrequency);\n    this._octaves = options.octaves;\n    this.Q = new Signal({\n      context: this.context,\n      value: options.Q,\n      units: \"positive\"\n    });\n    this._filtersL = this._makeFilters(options.stages, this._lfoL);\n    this._filtersR = this._makeFilters(options.stages, this._lfoR);\n    this.frequency = this._lfoL.frequency;\n    this.frequency.value = options.frequency;\n    // connect them up\n    this.connectEffectLeft(...this._filtersL);\n    this.connectEffectRight(...this._filtersR);\n    // control the frequency with one LFO\n    this._lfoL.frequency.connect(this._lfoR.frequency);\n    // set the options\n    this.baseFrequency = options.baseFrequency;\n    this.octaves = options.octaves;\n    // start the lfo\n    this._lfoL.start();\n    this._lfoR.start();\n    readOnly(this, [\"frequency\", \"Q\"]);\n  }\n  static getDefaults() {\n    return Object.assign(StereoEffect.getDefaults(), {\n      frequency: 0.5,\n      octaves: 3,\n      stages: 10,\n      Q: 10,\n      baseFrequency: 350\n    });\n  }\n  _makeFilters(stages, connectToFreq) {\n    const filters = [];\n    // make all the filters\n    for (let i = 0; i < stages; i++) {\n      const filter = this.context.createBiquadFilter();\n      filter.type = \"allpass\";\n      this.Q.connect(filter.Q);\n      connectToFreq.connect(filter.frequency);\n      filters.push(filter);\n    }\n    return filters;\n  }\n  /**\n   * The number of octaves the phase goes above the baseFrequency\n   */\n  get octaves() {\n    return this._octaves;\n  }\n  set octaves(octaves) {\n    this._octaves = octaves;\n    const max = this._baseFrequency * Math.pow(2, octaves);\n    this._lfoL.max = max;\n    this._lfoR.max = max;\n  }\n  /**\n   * The the base frequency of the filters.\n   */\n  get baseFrequency() {\n    return this._baseFrequency;\n  }\n  set baseFrequency(freq) {\n    this._baseFrequency = this.toFrequency(freq);\n    this._lfoL.min = this._baseFrequency;\n    this._lfoR.min = this._baseFrequency;\n    this.octaves = this._octaves;\n  }\n  dispose() {\n    super.dispose();\n    this.Q.dispose();\n    this._lfoL.dispose();\n    this._lfoR.dispose();\n    this._filtersL.forEach(f => f.disconnect());\n    this._filtersR.forEach(f => f.disconnect());\n    this.frequency.dispose();\n    return this;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}