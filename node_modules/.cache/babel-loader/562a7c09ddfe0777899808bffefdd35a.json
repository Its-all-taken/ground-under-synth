{"ast":null,"code":"import { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isArray, isDefined, isObject, isUndef } from \"../core/util/TypeCheck\";\nimport { ToneEvent } from \"./ToneEvent\";\n/**\n * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const part = new Tone.Part(((time, note) => {\n * \t// the notes given as the second element in the array\n * \t// will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }), [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n * Tone.Transport.start();\n * @example\n * const synth = new Tone.Synth().toDestination();\n * // use an array of objects as long as the object has a \"time\" attribute\n * const part = new Tone.Part(((time, value) => {\n * \t// the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }), [{ time: 0, note: \"C3\", velocity: 0.9 },\n * \t{ time: \"0:2\", note: \"C4\", velocity: 0.5 }\n * ]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Part extends ToneEvent {\n  constructor() {\n    super(optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]));\n    this.name = \"Part\";\n    /**\n     * Tracks the scheduled events\n     */\n    this._state = new StateTimeline(\"stopped\");\n    /**\n     * The events that belong to this part\n     */\n    this._events = new Set();\n    const options = optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]);\n    // make sure things are assigned in the right order\n    this._state.increasing = true;\n    // add the events\n    options.events.forEach(event => {\n      if (isArray(event)) {\n        this.add(event[0], event[1]);\n      } else {\n        this.add(event);\n      }\n    });\n  }\n  static getDefaults() {\n    return Object.assign(ToneEvent.getDefaults(), {\n      events: []\n    });\n  }\n  /**\n   * Start the part at the given time.\n   * @param  time    When to start the part.\n   * @param  offset  The offset from the start of the part to begin playing at.\n   */\n  start(time, offset) {\n    const ticks = this.toTicks(time);\n    if (this._state.getValueAtTime(ticks) !== \"started\") {\n      offset = defaultArg(offset, this._loop ? this._loopStart : 0);\n      if (this._loop) {\n        offset = defaultArg(offset, this._loopStart);\n      } else {\n        offset = defaultArg(offset, 0);\n      }\n      const computedOffset = this.toTicks(offset);\n      this._state.add({\n        id: -1,\n        offset: computedOffset,\n        state: \"started\",\n        time: ticks\n      });\n      this._forEach(event => {\n        this._startNote(event, ticks, computedOffset);\n      });\n    }\n    return this;\n  }\n  /**\n   * Start the event in the given event at the correct time given\n   * the ticks and offset and looping.\n   * @param  event\n   * @param  ticks\n   * @param  offset\n   */\n  _startNote(event, ticks, offset) {\n    ticks -= offset;\n    if (this._loop) {\n      if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n        if (event.startOffset < offset) {\n          // start it on the next loop\n          ticks += this._getLoopDuration();\n        }\n        event.start(new TicksClass(this.context, ticks));\n      } else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n        event.loop = false;\n        event.start(new TicksClass(this.context, ticks));\n      }\n    } else if (event.startOffset >= offset) {\n      event.start(new TicksClass(this.context, ticks));\n    }\n  }\n  get startOffset() {\n    return this._startOffset;\n  }\n  set startOffset(offset) {\n    this._startOffset = offset;\n    this._forEach(event => {\n      event.startOffset += this._startOffset;\n    });\n  }\n  /**\n   * Stop the part at the given time.\n   * @param  time  When to stop the part.\n   */\n  stop(time) {\n    const ticks = this.toTicks(time);\n    this._state.cancel(ticks);\n    this._state.setStateAtTime(\"stopped\", ticks);\n    this._forEach(event => {\n      event.stop(time);\n    });\n    return this;\n  }\n  /**\n   * Get/Set an Event's value at the given time.\n   * If a value is passed in and no event exists at\n   * the given time, one will be created with that value.\n   * If two events are at the same time, the first one will\n   * be returned.\n   * @example\n   * const part = new Tone.Part();\n   * part.at(\"1m\"); // returns the part at the first measure\n   * part.at(\"2m\", \"C2\"); // set the value at \"2m\" to C2.\n   * // if an event didn't exist at that time, it will be created.\n   * @param time The time of the event to get or set.\n   * @param value If a value is passed in, the value of the event at the given time will be set to it.\n   */\n  at(time, value) {\n    const timeInTicks = new TransportTimeClass(this.context, time).toTicks();\n    const tickTime = new TicksClass(this.context, 1).toSeconds();\n    const iterator = this._events.values();\n    let result = iterator.next();\n    while (!result.done) {\n      const event = result.value;\n      if (Math.abs(timeInTicks - event.startOffset) < tickTime) {\n        if (isDefined(value)) {\n          event.value = value;\n        }\n        return event;\n      }\n      result = iterator.next();\n    }\n    // if there was no event at that time, create one\n    if (isDefined(value)) {\n      this.add(time, value);\n      // return the new event\n      return this.at(time);\n    } else {\n      return null;\n    }\n  }\n  add(time, value) {\n    // extract the parameters\n    if (time instanceof Object && Reflect.has(time, \"time\")) {\n      value = time;\n      time = value.time;\n    }\n    const ticks = this.toTicks(time);\n    let event;\n    if (value instanceof ToneEvent) {\n      event = value;\n      event.callback = this._tick.bind(this);\n    } else {\n      event = new ToneEvent({\n        callback: this._tick.bind(this),\n        context: this.context,\n        value\n      });\n    }\n    // the start offset\n    event.startOffset = ticks;\n    // initialize the values\n    event.set({\n      humanize: this.humanize,\n      loop: this.loop,\n      loopEnd: this.loopEnd,\n      loopStart: this.loopStart,\n      playbackRate: this.playbackRate,\n      probability: this.probability\n    });\n    this._events.add(event);\n    // start the note if it should be played right now\n    this._restartEvent(event);\n    return this;\n  }\n  /**\n   * Restart the given event\n   */\n  _restartEvent(event) {\n    this._state.forEach(stateEvent => {\n      if (stateEvent.state === \"started\") {\n        this._startNote(event, stateEvent.time, stateEvent.offset);\n      } else {\n        // stop the note\n        event.stop(new TicksClass(this.context, stateEvent.time));\n      }\n    });\n  }\n  remove(time, value) {\n    // extract the parameters\n    if (isObject(time) && time.hasOwnProperty(\"time\")) {\n      value = time;\n      time = value.time;\n    }\n    time = this.toTicks(time);\n    this._events.forEach(event => {\n      if (event.startOffset === time) {\n        if (isUndef(value) || isDefined(value) && event.value === value) {\n          this._events.delete(event);\n          event.dispose();\n        }\n      }\n    });\n    return this;\n  }\n  /**\n   * Remove all of the notes from the group.\n   */\n  clear() {\n    this._forEach(event => event.dispose());\n    this._events.clear();\n    return this;\n  }\n  /**\n   * Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n   * @param after The time after which to cancel the scheduled events.\n   */\n  cancel(after) {\n    this._forEach(event => event.cancel(after));\n    this._state.cancel(this.toTicks(after));\n    return this;\n  }\n  /**\n   * Iterate over all of the events\n   */\n  _forEach(callback) {\n    if (this._events) {\n      this._events.forEach(event => {\n        if (event instanceof Part) {\n          event._forEach(callback);\n        } else {\n          callback(event);\n        }\n      });\n    }\n    return this;\n  }\n  /**\n   * Set the attribute of all of the events\n   * @param  attr  the attribute to set\n   * @param  value      The value to set it to\n   */\n  _setAll(attr, value) {\n    this._forEach(event => {\n      event[attr] = value;\n    });\n  }\n  /**\n   * Internal tick method\n   * @param  time  The time of the event in seconds\n   */\n  _tick(time, value) {\n    if (!this.mute) {\n      this.callback(time, value);\n    }\n  }\n  /**\n   * Determine if the event should be currently looping\n   * given the loop boundries of this Part.\n   * @param  event  The event to test\n   */\n  _testLoopBoundries(event) {\n    if (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {\n      event.cancel(0);\n    } else if (event.state === \"stopped\") {\n      // reschedule it if it's stopped\n      this._restartEvent(event);\n    }\n  }\n  get probability() {\n    return this._probability;\n  }\n  set probability(prob) {\n    this._probability = prob;\n    this._setAll(\"probability\", prob);\n  }\n  get humanize() {\n    return this._humanize;\n  }\n  set humanize(variation) {\n    this._humanize = variation;\n    this._setAll(\"humanize\", variation);\n  }\n  /**\n   * If the part should loop or not\n   * between Part.loopStart and\n   * Part.loopEnd. If set to true,\n   * the part will loop indefinitely,\n   * if set to a number greater than 1\n   * it will play a specific number of\n   * times, if set to false, 0 or 1, the\n   * part will only play once.\n   * @example\n   * const part = new Tone.Part();\n   * // loop the part 8 times\n   * part.loop = 8;\n   */\n  get loop() {\n    return this._loop;\n  }\n  set loop(loop) {\n    this._loop = loop;\n    this._forEach(event => {\n      event.loopStart = this.loopStart;\n      event.loopEnd = this.loopEnd;\n      event.loop = loop;\n      this._testLoopBoundries(event);\n    });\n  }\n  /**\n   * The loopEnd point determines when it will\n   * loop if Part.loop is true.\n   */\n  get loopEnd() {\n    return new TicksClass(this.context, this._loopEnd).toSeconds();\n  }\n  set loopEnd(loopEnd) {\n    this._loopEnd = this.toTicks(loopEnd);\n    if (this._loop) {\n      this._forEach(event => {\n        event.loopEnd = loopEnd;\n        this._testLoopBoundries(event);\n      });\n    }\n  }\n  /**\n   * The loopStart point determines when it will\n   * loop if Part.loop is true.\n   */\n  get loopStart() {\n    return new TicksClass(this.context, this._loopStart).toSeconds();\n  }\n  set loopStart(loopStart) {\n    this._loopStart = this.toTicks(loopStart);\n    if (this._loop) {\n      this._forEach(event => {\n        event.loopStart = this.loopStart;\n        this._testLoopBoundries(event);\n      });\n    }\n  }\n  /**\n   * The playback rate of the part\n   */\n  get playbackRate() {\n    return this._playbackRate;\n  }\n  set playbackRate(rate) {\n    this._playbackRate = rate;\n    this._setAll(\"playbackRate\", rate);\n  }\n  /**\n   * The number of scheduled notes in the part.\n   */\n  get length() {\n    return this._events.size;\n  }\n  dispose() {\n    super.dispose();\n    this.clear();\n    return this;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}